= Getting started with Hibernate Reactive
:awestruct-layout: project-standard
:awestruct-project: reactive
:page-interpolate: true
:toc:
:toc-placement: preamble
:hibernate-reactive-version: #{latest_release(page).version}
:vertx-version: #{latest_release(page)['dependencies'].get_version('io.vertx', 'vertx-sql-client')}
  
[[reactive-gettingstarted]]

Usage is very straightforward for anyone with any prior experience with
Hibernate or JPA.

== Example program

There is a very simple example program in the link:https://github.com/hibernate/hibernate-reactive/tree/master/example[`example`
directory on GitHub].

== Including Hibernate Reactive in your project

In your project, you need to add the dependency to Hibernate Reactive and
the Vert.x clients to connect to the databases of your choice:

[source]
[subs="verbatim,attributes"]
.Gradle dependencies
----
implementation org.hibernate.reactive:hibernate-reactive-core:{hibernate-reactive-version}
runtimeOnly io.vertx:vertx-pg-client:{vertx-version}
runtimeOnly io.vertx:vertx-mysql-client:{vertx-version}
runtimeOnly io.vertx:vertx-db2-client:{vertx-version}
----

== Configuration

Hibernate Reactive is configured via the standard JPA `persistence.xml` 
document which must be placed, as usual, in the `/META-INF` directory.

The only configuration specific to Hibernate Reactive is the persistence
`<provider>` element, which must be explicit:

    <provider>org.hibernate.reactive.provider.ReactivePersistenceProvider</provider>

Otherwise, configuration is almost completely transparent. Configure 
Hibernate exactly as you usually would, noting that most configuration 
properties related to JDBC or JTA aren't relevant in the context of 
Hibernate Reactive.

[source, XML]
[subs="verbatim,attributes"]
.Example for persistence.xml
----
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
             version="2.0">

    <persistence-unit name="example">
        <provider>org.hibernate.reactive.provider.ReactivePersistenceProvider</provider>

        <class>org.hibernate.example.reactive.Author</class>
        <class>org.hibernate.example.reactive.Book</class>

        <properties>

            <!-- PostgreSQL -->
            <property name="javax.persistence.jdbc.url"
	              value="jdbc:postgresql://localhost/hreact"/>

            <!-- MySQL -->
            <!--property name="javax.persistence.jdbc.url"
	                 value="jdbc:mysql://localhost/hreact"/-->

            <!-- Credentials -->
            <property name="javax.persistence.jdbc.user" value="hreact"/>
            <property name="javax.persistence.jdbc.password" value="hreact"/>

            <!-- The Vert.x SQL Client connection pool size -->
            <property name="hibernate.connection.pool_size" value="10"/>

            <!-- Automatic schema export -->
            <property name="javax.persistence.schema-generation.database.action"
	              value="drop-and-create"/>

            <!-- SQL statement logging -->
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.show_sql" value="true"/>

        </properties>

    </persistence-unit>

</persistence>
----

== Obtaining a reactive session factory

Obtain a Hibernate `SessionFactory` or JPA `EntityManagerFactory` 
just as you normally would, for example, by calling:

[source, JAVA]
----
    EntityManagerFactory emf = Persistence.createEntityManagerFactory("example");
----

Now, `unwrap()` the reactive `SessionFactory`:
 
[source, JAVA]
----
    Stage.SessionFactory sessionFactory = emf.unwrap(Stage.SessionFactory.class);
----

The type `Stage.SessionFactory` gives access to reactive APIs based on 
Java's `CompletionStage`.

If you prefer to use the link:https://smallrye.io/smallrye-mutiny/[Mutiny]-based API, `unwrap()` the type 
`Mutiny.SessionFactory`:

[source, JAVA]
----
    Mutiny.SessionFactory sessionFactory = emf.unwrap(Mutiny.SessionFactory.class);
----

== Using the reactive session

The `Session` interface has methods with the same names as methods of the
JPA `EntityManager`. However, each of these methods returns its result via
a `CompletionStage` (or Mutiny `Uni`), for example:

[source, JAVA]
----
    session.find(Book.class, book.id)
            .thenAccept( book -> System.out.println(book.title + " is a great book!") )
----

Methods with no meaningful return value return a reference to the `Session`:

[source, JAVA]
----
    session.persist(book)
            .thenCompose( s -> s.flush() )
            .whenComplete( (s, e) -> s.close() )
----

That `createQuery()` method produces a reactive `Query`, allowing HQL / JPQL
queries to be executed asynchronously, always returning their results via a
`CompletionStage`:

[source, JAVA]
----
    session.createQuery("select title from Book order by title desc")
            .getResultList()
            .thenAccept(System.out::println)
----

If you already know Hibernate, and if you already have some experience with
reactive programming, there's not much new to learn here: you should
immediately feel right at home.

== Fetching lazy associations

In Hibernate ORM, lazy associations are fetched transparently when the
association is fist accessed within a session. In Hibernate Reactive, 
association fetching is an asynchronous process that produces a result
via a `CompletionStage` (or Mutiny `Uni`).

Therefore, lazy fetching is an explicit operation named `fetch()`,
a static method of `Stage` and `Mutiny`:

[source, JAVA]
----
    session.find(Author.class, author.id)
            .thenCompose( author -> Stage.fetch(author.books) )
            .thenAccept( books -> ... )
----

Of course, this isn't necessary if you fetch the association eagerly.

== Field-level lazy fetching

Similarly, field-level lazy fetching&mdash;an advanced feature, which 
is only supported in conjunction with Hibernate's optional compile-time 
bytecode enhancer&mdash;is also an explicit operation:

[source, JAVA]
----
    session.find(Book.class, book.id)
            .thenCompose( book -> session.fetch(book, Book_.isbn) )
            .thenAccept( isbn -> ... )
----

Note that the field to fetch is identified by a JPA metamodel `Attribute`.

We don't encourage you to use field-level lazy fetching unless you have
very specific requirements.

== Transactions

The `withTransaction()` method performs work within the scope of a database 
transaction. 

[source, JAVA]
----
    session.withTransaction( tx -> session.persist(book) )
----

The session is automatically flushed at the end of the transaction.

For extra convenience, there's a method that opens a session and starts a
transaction in one call:

[source, JAVA]
----
    sessionFactory.withTransaction( (session, tx) -> session.persist(book) )
----

