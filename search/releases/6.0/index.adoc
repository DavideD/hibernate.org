:awestruct-layout: project-releases-series
:awestruct-project: search
:awestruct-series_version: "6.0"

[[preview-status]]
=== Preview status

Hibernate Search 6.0 is currently a *technology preview*.

While the core of Hibernate Search 6 is ready for use in a production environment,
there are still some limitations:

* APIs are expected to stay stable, but may still change if major implementation issues are detected.
* Some of the less frequently used features from Hibernate Search 5 are still missing.
* There may still be some performance bottlenecks.

If you encounter problems, be sure to https://hibernate.atlassian.net/browse/HSEARCH[report them]:
new preview versions are released regularly.

=== Dependency upgrades

[[orm-version]]
==== Hibernate ORM

Hibernate Search 6 still relies on ORM 5.4 at the moment,
because it requires features that are not yet implemented in ORM 6 (still in development).

Note that only Hibernate ORM 5.4.4.Final or later will work correctly;
5.4.3.Final and earlier will not.

[[lucene-8]]
==== Lucene 8
// Old anchor, kept here to avoid dead links
[[lucene-7]]

The Lucene backend now uses Lucene 8.5.

[[elasticsearch-7]]
==== Elasticsearch 7
// Old anchor, kept here to avoid dead links
[[elasticsearch-6]]

The Elasticsearch backend now works with Elasticsearch 5.6, 6.8 or 7.7.
Support for older versions of Elasticsearch was dropped.

[[api-refresh]]
=== API refresh

A lot of APIs have been changed, for multiple reasons.

==== More consistent API types

The API types consistently use the `Search` prefix: no more mixing `FullText` with `Search` or simply no prefix.

Additionally, the `SearchQuery` type (previously `FullTextQuery`) now defines its own methods
instead of extending JPA's `TypeQuery`, allowing for an API that makes more sense considering that an index,
not a database, is being targeted.
It is still possible to create an adapter that implements JPA's `TypeQuery`.

==== No more Lucene in Hibernate Search APIs

Hibernate Search APIs now abstract from the Lucene APIs,
so that alternative backends such as Elasticsearch can be used without having Lucene on your classpath.

This should also allow us to upgrade the Lucene version more easily:
in Search 5, as Lucene was "part of" our APIs,
we were severely limited when we wanted to upgrade to a newer Lucene version,
because any breaking change in Lucene could mean a breaking change for our users, too.
Now that using Lucene APIs is no longer necessary to use Hibernate Search,
upgrades should be faster.

==== New Search DSL

The Search DSL is brand new, with several improvements:

* Ability to use lambdas for more concise query definition, even when queries are complex.
* Type-safe projections thanks to the brand-new projection DSL.
* Various new features and improvements such as a new `exists` predicate,
the ability to override analyzers on a per-predicate basis, ...
* Injection of native predicates (`org.apache.lucene.search.Query` for Lucene, JSON for Elasticsearch)
within DSL-created predicates.
This is not new for the Lucene integration, but it is for the Elasticsearch integration.
See https://docs.jboss.org/hibernate/search/6.0/reference/en-US/html_single/#search-dsl-predicate-extensions[predicate extensions].
* Simpler syntax for predicates when targeting multiple types in a single query:
instantiating multiple `QueryBuilders` is no longer needed,
Hibernate Search takes into account that multiple types are targeted
and automatically checks that targeted fields are compatible across all targeted indexes.

[[bridge-2.0]]
==== Bridge 2.0

The bridge APIs had to change as part of the API refresh,
so we took this opportunity to overhaul bridge APIs to make bridges more powerful.

The new Bridge APIs are completely different, but with a lot of improvements:

* Custom (user-defined) bridge annotations, allowing the passing of type-safe parameters, and not just strings.
* Better support for dirty checking optimization in bridges (in `TypeBridge` in particular),
by allowing bridges to declare what parts of the entity they use.
* Predicates on non-String fields will work without having to bypass bridges (`.ignoreFieldBridge()`) like in Search 5.
* And more!

[[automatic-indexing]]
=== Easier to use, smarter automatic indexing

In Hibernate Search 6, automatic indexing is easier to configure correctly:

* When using `@IndexedEmbedded` on an association,
Hibernate Search 6 infers the inverse side of the association from Hibernate ORM metadata,
which allows it to automatically reindex the class hosting the `@IndexedEmbedded` annotation
when the target of the association changes. `@ContainedIn` is no longer needed.
* When the inverse side of an association cannot be resolved,
Hibernate Search 6 will report a mapping error, allowing you to detect risks of out-of-sync indexes early.
* You can still opt out of automatic reindexing using `@IndexingDependency(reindexOnUpdate = ReindexOnUpdate.NO)`.
See https://docs.jboss.org/hibernate/search/6.0/reference/en-US/html_single/#mapper-orm-reindexing-reindexonupdate[this section of the documentation].

Hibernate Search 6 is also smarter with reindexing.
When a property changes in an entity that is indexed-embedded in multiple other entities,
Hibernate Search 6 will only traverse associations to entities that are actually
affected by the change, based on `@IndexedEmbedded(includePaths = ...)` and other metadata.

[[runtime-joins]]
=== Runtime joins with nested documents

Hibernate Search 6.0 introduces "nested" fields and predicates,
similar to the feature with the same name in Elasticsearch.

This means in particular that embedded entities can be searched much more finely,
for example searching for that one book whose author has a given first name *and* last name.
With the right query, no longer will Hibernate Search return a book authored by "John Smith" and "Jane Doe"
when you were looking for "John Doe"!

For details, see https://docs.jboss.org/hibernate/search/6.0/reference/en-US/html_single/#mapper-orm-indexedembedded-storage[`@IndexedEmbedded` storage type]
in the reference documentation.
